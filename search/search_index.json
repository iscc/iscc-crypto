{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ISCC - Crypto","text":"<p><code>iscc-crypto</code> is the cryptographic signing and verification module for the ISCC (International Standard Content Code) Framework.</p> <p>[!CAUTION] This is a proof of concept. All releases with version numbers below v1.0.0 may break backward compatibility. The algorithms and code of this repository are experimental and not part of the official ISO 24138:2024 standard. This library has not undergone a formal security audit by independent third parties. While we strive to follow best practices and have implemented various security measures, the absence of an audit means there may be undiscovered vulnerabilities. Therefore, this library should not be used in production environments where strong security guarantees are critical.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Ed25519 key generation and management</li> <li>JSON canonicalization and signing</li> <li>W3C Verifiable Credentials Data Integrity proofs</li> <li>Multibase and multikey support</li> <li>Minimal external dependencies for core cryptographic operations</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Use the package manager pip to install <code>iscc-crypto</code>:</p> <pre><code>pip install iscc-crypto\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; import iscc_crypto as icr\n\n&gt;&gt;&gt; # Use fixed test keys for deterministic output\n&gt;&gt;&gt; keypair = icr.key_from_secret(\"z3u2So9EAtuYVuxGog4F2ksFGws8YT7pBPs4xyRbv3NJgrNA\")\n\n&gt;&gt;&gt; # Sign a JSON document\n&gt;&gt;&gt; doc = {\"title\": \"My Document\", \"content\": \"Important data\"}\n&gt;&gt;&gt; signed_doc = icr.sign_json(doc, keypair)\n\n&gt;&gt;&gt; # Show the signed document structure\n&gt;&gt;&gt; print(json.dumps(signed_doc, indent=2))\n{\n  \"title\": \"My Document\",\n  \"content\": \"Important data\",\n  \"signature\": {\n    \"version\": \"ISCC-SIG v1.0\",\n    \"pubkey\": \"z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\",\n    \"proof\": \"z5xCgXk6tGJTVcvrcvVok5XgLn5Mefo49ztwwW8QCmjoySH4ZEkri4XoY2JjiyaD7yD4Na7eoGPqmhPoeM2uvBmF8\"\n  }\n}\n\n&gt;&gt;&gt; # Verify the signed document\n&gt;&gt;&gt; icr.verify_json(signed_doc)\nVerificationResult(signature_valid=True, identity_verified=None, message=None)\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentation is published at https://crypto.iscc.codes</p>"},{"location":"#development","title":"Development","text":"<p>Requirements</p> <ul> <li>Python 3.10 or higher</li> <li>UV for dependency management</li> </ul> <p>Development Setup</p> <pre><code>git clone https://github.com/iscc/iscc-crypto.git\ncd iscc-crypto\nuv sync\n</code></pre> <p>Testing</p> <p>Run the test suite:</p> <pre><code>uv run pytest\n</code></pre>"},{"location":"#maintainers","title":"Maintainers","text":"<p>@titusz</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Pull requests are welcome. For significant changes, please open an issue first to discuss your plans. Please make sure to update tests as appropriate.</p> <p>You may also want to join our developer chat on Telegram at https://t.me/iscc_dev.</p>"},{"location":"#license","title":"License","text":"<p><code>iscc-crypto</code> is licensed under the Apache License, Version 2.0</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#030-unreleased","title":"[0.3.0] - Unreleased","text":"<ul> <li>Added CLI for cryptographic identity management with setup, verify, and info commands</li> <li>Added signature version tracking for ISCC signatures</li> <li>Added URI resolution module with support for did:key, did:web, HTTP(S), and CID documents</li> <li>Added validation for Controlled Identifier Documents</li> <li>Added ISCC signature specification and example</li> <li>Enhanced JSON verification with external public key support</li> <li>Migrated from Poetry to UV for dependency management</li> <li>Updated GitHub Actions workflow for UV setup</li> </ul>"},{"location":"changelog/#020-2024-12-09","title":"[0.2.0] - 2024-12-09","text":"<ul> <li>Added https://www.w3.org/TR/vc-di-eddsa/ context injection</li> </ul>"},{"location":"changelog/#010-2024-12-09","title":"[0.1.0] - 2024-12-09","text":"<ul> <li>Initial alpha release</li> </ul>"},{"location":"conventions/","title":"Coding Convetions","text":"<ul> <li>Write pragmatic, easily testable, and performant code!</li> <li>Prefer short and pure functions where possible!</li> <li>Keep the number of function arguments as low as possible!</li> <li>Don\u00b4t use nested functions!</li> <li>Write concise and to-the-point docstrings for all functions!</li> <li>Use type comments style (PEP 484) instead of function annotations!</li> <li>Always add a correct PEP 484 style type comment as the first line after the function definition!</li> <li>Use built-in collection types as generic types for annotations (PEP 585)!</li> <li>Use the | (pipe) operator for writing union types (PEP 604)!</li> <li>Avoid the use of <code>isinstance</code> at all cost!</li> <li>NEVER USE <code>isinstance</code> IN PYTHON CODE!!!</li> <li>Verification failures should always raise an error with a helpful message</li> </ul> <p>Example function with type annotations and docstring:</p> <pre><code>def tokenize_chunks(chunks, max_len=None):\n    # type: (list[str], int|None) -&gt; dict\n    \"\"\"\n    Tokenize text chunks into model-compatible formats.\n\n    :param chunks: Text chunks to tokenize.\n    :param max_len: Truncates chunks above max_len characters\n    :return: Dictionary of tokenized data including input IDs, attention masks, and type IDs.\n    \"\"\"\n</code></pre>"},{"location":"iscc-sig-spec/","title":"ISCC Signature Specification","text":"<p>This specification defines a simple JSON signature format for ISCC metadata using EdDSA signatures and JSON Canonicalization Scheme (JCS).</p>"},{"location":"iscc-sig-spec/#why-a-custom-signature-format","title":"Why a Custom Signature Format?","text":"<p>The ISCC framework requires a signature format that balances simplicity, flexibility, and standards compliance:</p> <ul> <li>Simplicity: Unlike complex standards like JSON-LD signatures or JWT, ISCC signatures are straightforward   JSON objects that developers can implement without extensive cryptographic libraries</li> <li>Flexibility: The format supports three verification modes (proof-only, self-verifying, identity-bound)   allowing use cases from simple integrity checks to full identity verification</li> <li>Minimal Dependencies: Uses only Ed25519 and JCS, avoiding heavyweight dependencies like JSON-LD processors   or JWT libraries</li> <li>Identity Agnostic: Works with any identity system (DIDs, CIDs, URLs) without requiring specific identity   infrastructure</li> <li>Backward Compatible: The simple structure ensures long-term stability and easy migration paths</li> </ul>"},{"location":"iscc-sig-spec/#overview","title":"Overview","text":"<p>ISCC Signatures add a <code>signature</code> object to any JSON document, providing cryptographic integrity and optional identity attribution. The signature is computed over the entire JSON object using JCS canonicalization.</p>"},{"location":"iscc-sig-spec/#signature-format","title":"Signature Format","text":"<pre><code>{\n  \"your\": \"data\",\n  \"signature\": {\n    \"version\": \"ISCC-SIG v1.0\",\n    \"controller\": \"&lt;optional-identity-uri&gt;\",\n    \"keyid\": \"&lt;optional-key-identifier&gt;\",\n    \"pubkey\": \"&lt;optional-multibase-public-key&gt;\",\n    \"proof\": \"&lt;multibase-signature&gt;\"\n  }\n}\n</code></pre>"},{"location":"iscc-sig-spec/#fields","title":"Fields","text":"<ul> <li>version (required): Must be <code>\"ISCC-SIG v1.0\"</code></li> <li>controller (optional): URI identifying the key controller (e.g., DID or CID)</li> <li>keyid (optional): Specific key identifier within the controller document</li> <li>pubkey (optional): Ed25519 public key in multibase format (z-base58-btc with ED01 prefix)</li> <li>proof (required): EdDSA signature in multibase format (z-base58-btc)</li> </ul>"},{"location":"iscc-sig-spec/#signature-types","title":"Signature Types","text":""},{"location":"iscc-sig-spec/#proof_only","title":"PROOF_ONLY","text":"<p>Minimal signature containing only version and proof. Requires out-of-band public key for verification.</p>"},{"location":"iscc-sig-spec/#self_verifying","title":"SELF_VERIFYING","text":"<p>Includes the public key for standalone verification without external dependencies.</p>"},{"location":"iscc-sig-spec/#identity_bound","title":"IDENTITY_BOUND","text":"<p>Includes controller URI and public key for full attribution and identity verification.</p>"},{"location":"iscc-sig-spec/#auto-default","title":"AUTO (default)","text":"<p>Includes all available fields from the signing keypair.</p>"},{"location":"iscc-sig-spec/#signing-process","title":"Signing Process","text":"<ol> <li>Ensure input JSON has no existing <code>signature</code> field</li> <li>Create a copy and add <code>signature</code> object with:</li> <li><code>version</code>: \"ISCC-SIG v1.0\"</li> <li>Optional fields based on signature type</li> <li>Canonicalize the entire object using JCS</li> <li>Sign the canonical bytes with Ed25519</li> <li>Encode signature as multibase (z-base58-btc)</li> <li>Add signature to <code>signature.proof</code> field</li> </ol>"},{"location":"iscc-sig-spec/#verification-process","title":"Verification Process","text":"<ol> <li>Extract and validate <code>signature</code> object:</li> <li>Check <code>version</code> equals \"ISCC-SIG v1.0\"</li> <li>Extract <code>proof</code> field</li> <li>Obtain public key from:</li> <li><code>signature.pubkey</code> field (if present)</li> <li>External parameter (if provided)</li> <li>Create copy without <code>signature.proof</code> field</li> <li>Canonicalize using JCS</li> <li>Verify EdDSA signature against canonical bytes</li> </ol>"},{"location":"iscc-sig-spec/#identity-verification-optional","title":"Identity Verification (Optional)","text":"<p>When an identity document is provided:</p> <ol> <li>Check if <code>signature.controller</code> exists</li> <li>Verify the public key is authorized in the identity document's <code>verificationMethod</code> array</li> <li>Match verification methods by:</li> <li>Same controller URI AND</li> <li>Same public key value (publicKeyMultibase)</li> <li>If <code>keyid</code> is provided: also match against verification method's id</li> <li>If <code>keyid</code> is absent: the public key itself acts as the identifier</li> </ol>"},{"location":"iscc-sig-spec/#implementation-requirements","title":"Implementation Requirements","text":"<ul> <li>Cryptography: Ed25519 signatures per RFC 8032</li> <li>Canonicalization: JSON Canonicalization Scheme (RFC 8785)</li> <li>Encoding: Multibase z-base58-btc for keys and signatures</li> <li>Public Keys: 34-byte format with 2-byte ED01 prefix + 32-byte key</li> <li>Signatures: 64-byte Ed25519 signatures</li> </ul>"},{"location":"iscc-sig-spec/#iscc-signature-example","title":"ISCC Signature Example","text":""},{"location":"iscc-sig-spec/#keypair-information","title":"Keypair Information","text":"<ul> <li>Public Key: <code>z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx</code></li> <li>Secret Key: <code>z3u2So9EAtuYVuxGog4F2ksFGws8YT7pBPs4xyRbv3NJgrNA</code></li> <li>Controller: <code>did:web:crypto.iscc.codes:alice</code></li> </ul>"},{"location":"iscc-sig-spec/#controlled-identity-document","title":"Controlled Identity Document","text":"<p>Must be published at http://crypto.iscc.codes/alice/did.json:</p> <pre><code>{\n  \"id\": \"did:web:crypto.iscc.codes:alice\",\n  \"verificationMethod\": [\n    {\n      \"id\": \"did:web:crypto.iscc.codes:alice#z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\",\n      \"type\": \"Multikey\",\n      \"controller\": \"did:web:crypto.iscc.codes:alice\",\n      \"publicKeyMultibase\": \"z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\"\n    }\n  ],\n  \"authentication\": [\n    \"did:web:crypto.iscc.codes:alice#z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\"\n  ],\n  \"assertionMethod\": [\n    \"did:web:crypto.iscc.codes:alice#z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\"\n  ],\n  \"capabilityDelegation\": [\n    \"did:web:crypto.iscc.codes:alice#z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\"\n  ],\n  \"capabilityInvocation\": [\n    \"did:web:crypto.iscc.codes:alice#z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\"\n  ]\n}\n</code></pre>"},{"location":"iscc-sig-spec/#document-to-be-signed","title":"Document to be Signed","text":"<pre><code>{\n  \"@context\": \"http://purl.org/iscc/context\",\n  \"@type\": \"VideoObject\",\n  \"$schema\": \"http://purl.org/iscc/schema\",\n  \"iscc\": \"ISCC:KACYPXW445FTYNJ3CYSXHAFJMA2HUWULUNRFE3BLHRSCXYH2M5AEGQY\",\n  \"name\": \"The Never Ending Story\",\n  \"description\": \"a 1984 fantasy film co-written and directed by *Wolfgang Petersen*\"\n}\n</code></pre>"},{"location":"iscc-sig-spec/#example-identity_bound-signature","title":"Example: IDENTITY_BOUND Signature","text":"<p>Includes controller URI and public key for full attribution.</p> <pre><code>{\n  \"@context\": \"http://purl.org/iscc/context\",\n  \"@type\": \"VideoObject\",\n  \"$schema\": \"http://purl.org/iscc/schema\",\n  \"iscc\": \"ISCC:KACYPXW445FTYNJ3CYSXHAFJMA2HUWULUNRFE3BLHRSCXYH2M5AEGQY\",\n  \"name\": \"The Never Ending Story\",\n  \"description\": \"a 1984 fantasy film co-written and directed by *Wolfgang Petersen*\",\n  \"signature\": {\n    \"version\": \"ISCC-SIG v1.0\",\n    \"controller\": \"did:web:crypto.iscc.codes:alice\",\n    \"pubkey\": \"z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\",\n    \"proof\": \"z3fVSTAfmNZTp1unwoXsyQa9sUx7gAxaZVavBLEPA5muup5ukxbCrirS8jcuhKzvQ3kp6UCJz2RA5wkZhYZ49o5wr\"\n  }\n}\n</code></pre>"},{"location":"usage-guide/","title":"ISCC-CRYPTO Usage Guide","text":""},{"location":"usage-guide/#overview","title":"Overview","text":"<p>ISCC-CRYPTO is a Python package for cryptographic operations related to ISCC (International Standard Content Code). It provides Ed25519 key management and signing capabilities for verifiable credentials following W3C standards.</p>"},{"location":"usage-guide/#installation","title":"Installation","text":"<pre><code>pip install iscc-crypto\n</code></pre>"},{"location":"usage-guide/#key-management","title":"Key Management","text":""},{"location":"usage-guide/#generate-new-keys","title":"Generate New Keys","text":"<pre><code>from iscc_crypto import key_generate\n\n# Generate a simple Ed25519 keypair without controller info\nkeypair = key_generate()\nprint(keypair.public_key)    # z-base58 encoded public key\nprint(keypair.secret_key)    # z-base58 encoded secret key\n\n\n# Generate a new Ed25519 keypair with controller and key ID\nkeypair = key_generate(\n    controller=\"https://example.com\",\n    key_id=\"key-1\"\n)\nprint(keypair.controller)    # https://example.com\nprint(keypair.key_id)       # key-1\n\n# Access the controller document\nprint(keypair.controller_document)  # W3C controller document\n</code></pre>"},{"location":"usage-guide/#load-existing-keys","title":"Load Existing Keys","text":"<pre><code>from iscc_crypto import key_from_secret\n\n# Load keypair without controller info\nkeypair = key_from_secret(\"z...\")\n\n# Load keypair from existing secret key with controller info\nkeypair = key_from_secret(\n    secret_key=\"z...\",  # z-base58 encoded secret key\n    controller=\"https://example.com\",\n    key_id=\"key-1\"\n)\n</code></pre>"},{"location":"usage-guide/#load-keys-from-environment","title":"Load Keys from Environment","text":"<pre><code>from iscc_crypto import key_from_env\n\n# Load keypair from environment variables:\n# - ISCC_CRYPTO_SECRET_KEY: Required z-base58 encoded secret key\n# - ISCC_CRYPTO_CONTROLLER: Optional controller URL\n# - ISCC_CRYPTO_KEY_ID: Optional key identifier\nkeypair = key_from_env()\n</code></pre>"},{"location":"usage-guide/#signing-operations","title":"Signing Operations","text":""},{"location":"usage-guide/#sign-raw-data","title":"Sign Raw Data","text":"<pre><code>from iscc_crypto import sign_raw\n\n# Sign raw bytes\nsignature = sign_raw(b\"data to sign\", keypair)\n</code></pre>"},{"location":"usage-guide/#sign-json-data","title":"Sign JSON Data","text":"<pre><code>from iscc_crypto import sign_json\n\n# Sign JSON object\ndata = {\"key\": \"value\"}\nsigned = sign_json(data, keypair)\n</code></pre>"},{"location":"usage-guide/#sign-verifiable-credentials","title":"Sign Verifiable Credentials","text":"<pre><code>from iscc_crypto import sign_vc\n\n# Sign a verifiable credential\nvc = {\n    \"@context\": [\"https://www.w3.org/ns/credentials/v2\"],\n    \"type\": [\"VerifiableCredential\"]\n}\nsigned_vc = sign_vc(vc, keypair)\n</code></pre>"},{"location":"usage-guide/#verification","title":"Verification","text":"<p>All verification functions return a <code>VerificationResult</code> object with two fields:</p> <ul> <li><code>is_valid</code>: Boolean indicating if verification succeeded</li> <li><code>message</code>: Optional error message if verification failed</li> </ul> <p>By default, verification functions raise a <code>VerificationError</code> on failure. Pass <code>raise_on_error=False</code> to get a <code>VerificationResult</code> instead.</p>"},{"location":"usage-guide/#verify-raw-signatures","title":"Verify Raw Signatures","text":"<pre><code>from iscc_crypto import verify_raw\n\n# Verify raw signature (raises VerificationError on failure)\nresult = verify_raw(payload, signature, keypair.pk_obj)\nprint(result.is_valid)  # True\n\n# Get VerificationResult instead of raising\nresult = verify_raw(payload, signature, keypair.pk_obj, raise_on_error=False)\nif not result.is_valid:\n    print(f\"Verification failed: {result.message}\")\n</code></pre>"},{"location":"usage-guide/#verify-json-signatures","title":"Verify JSON Signatures","text":"<pre><code>from iscc_crypto import verify_json\n\n# Verify signed JSON\nresult = verify_json(signed_data, raise_on_error=False)\nif result.is_valid:\n    print(\"Signature valid\")\nelse:\n    print(f\"Invalid signature: {result.message}\")\n</code></pre>"},{"location":"usage-guide/#verify-credentials","title":"Verify Credentials","text":"<pre><code>from iscc_crypto import verify_vc\n\n# Verify signed credential\nresult = verify_vc(signed_credential, raise_on_error=False)\nif not result.is_valid:\n    print(f\"Verification failed: {result.message}\")\n</code></pre>"},{"location":"usage-guide/#important-notes","title":"Important Notes","text":"<ul> <li>All public/secret keys use z-base58 multibase encoding</li> <li>Signatures follow the EdDSA-JCS-2022 cryptosuite specification</li> <li>Verification methods support both error raising and result objects</li> <li>Key generation supports optional controller URLs and key IDs</li> <li>All signing operations create copies and don't modify input data</li> </ul>"}]}