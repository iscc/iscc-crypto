{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ISCC - Crypto","text":"<p><code>iscc-crypto</code> is the cryptographic signing and verification module for the ISCC (International Standard Content Code) Framework.</p> <p>[!CAUTION] This is a proof of concept. All releases with version numbers below v1.0.0 may break backward compatibility. The algorithms and code of this repository are experimental and not part of the official ISO 24138:2024 standard. This library has not undergone a formal security audit by independent third parties. While we strive to follow best practices and have implemented various security measures, the absence of an audit means there may be undiscovered vulnerabilities. Therefore, this library should not be used in production environments where strong security guarantees are critical.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Ed25519 key generation and management</li> <li>JSON canonicalization and signing</li> <li>W3C Verifiable Credentials Data Integrity proofs</li> <li>Multibase and multikey support</li> <li>Cryptographic nonce generation with embedded node identifier</li> <li>Command-line interface for key generation and identity management</li> <li>Minimal external dependencies for core cryptographic operations</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Use the package manager pip to install <code>iscc-crypto</code>:</p> <pre><code>pip install iscc-crypto\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; import iscc_crypto as icr\n\n&gt;&gt;&gt; keypair = icr.key_from_secret(\"z3u2So9EAtuYVuxGog4F2ksFGws8YT7pBPs4xyRbv3NJgrNA\")\n\n&gt;&gt;&gt; # Sign a JSON document\n&gt;&gt;&gt; doc = {\"title\": \"My Document\", \"content\": \"Important data\"}\n&gt;&gt;&gt; signed_doc = icr.sign_json(doc, keypair)\n\n&gt;&gt;&gt; # Show the signed document structure\n&gt;&gt;&gt; print(json.dumps(signed_doc, indent=2))\n{\n  \"title\": \"My Document\",\n  \"content\": \"Important data\",\n  \"signature\": {\n    \"version\": \"ISCC-SIG v1.0\",\n    \"pubkey\": \"z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\",\n    \"proof\": \"z5xCgXk6tGJTVcvrcvVok5XgLn5Mefo49ztwwW8QCmjoySH4ZEkri4XoY2JjiyaD7yD4Na7eoGPqmhPoeM2uvBmF8\"\n  }\n}\n\n&gt;&gt;&gt; # Verify the signed document\n&gt;&gt;&gt; icr.verify_json(signed_doc)\nVerificationResult(signature_valid=True, identity_verified=None, message=None)\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentation is published at https://crypto.iscc.codes</p>"},{"location":"#development","title":"Development","text":"<p>Requirements</p> <ul> <li>Python 3.10 or higher</li> <li>UV for dependency management</li> </ul> <p>Development Setup</p> <pre><code>git clone https://github.com/iscc/iscc-crypto.git\ncd iscc-crypto\nuv sync\n</code></pre> <p>Testing</p> <p>Run the test suite:</p> <pre><code>uv run pytest\n</code></pre>"},{"location":"#maintainers","title":"Maintainers","text":"<p>@titusz</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Pull requests are welcome. For significant changes, please open an issue first to discuss your plans. Please make sure to update tests as appropriate.</p> <p>You may also want to join our developer chat on Telegram at https://t.me/iscc_dev.</p>"},{"location":"#license","title":"License","text":"<p><code>iscc-crypto</code> is licensed under the Apache License, Version 2.0</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#050-2025-08-13","title":"[0.5.0] - 2025-08-13","text":"<ul> <li>Added controller-based verification method support in VC signing</li> <li>Updated dependencies in lock file</li> </ul>"},{"location":"changelog/#040-2025-07-28","title":"[0.4.0] - 2025-07-28","text":"<ul> <li>Added cryptographic nonce generation with embedded node identifier</li> <li>Added keygen command for cryptographic key generation</li> <li>Added version display in CLI help output</li> <li>Added -h as short notation for the help option in CLI</li> <li>Added \"Getting Started\" documentation</li> <li>Updated project URLs in pyproject.toml</li> <li>Updated version retrieval method</li> </ul>"},{"location":"changelog/#030-2025-06-10","title":"[0.3.0] - 2025-06-10","text":"<ul> <li>Added CLI for cryptographic identity management with setup, validate-identity, and info commands</li> <li>Added signature version tracking for ISCC signatures</li> <li>Added URI resolution module with support for did:key, did:web, HTTP(S), and CID documents</li> <li>Added validation for Controlled Identifier Documents</li> <li>Added ISCC signature specification and example</li> <li>Enhanced JSON verification with external public key support</li> <li>Migrated from Poetry to UV for dependency management</li> <li>Updated GitHub Actions workflow for UV setup</li> </ul>"},{"location":"changelog/#020-2024-12-09","title":"[0.2.0] - 2024-12-09","text":"<ul> <li>Added https://www.w3.org/TR/vc-di-eddsa/ context injection</li> </ul>"},{"location":"changelog/#010-2024-12-09","title":"[0.1.0] - 2024-12-09","text":"<ul> <li>Initial alpha release</li> </ul>"},{"location":"conventions/","title":"Coding Convetions","text":"<ul> <li>Write pragmatic, easily testable, and performant code!</li> <li>Prefer short and pure functions where possible!</li> <li>Keep the number of function arguments as low as possible!</li> <li>Don\u00b4t use nested functions!</li> <li>Write concise and to-the-point docstrings for all functions!</li> <li>Use type comments style (PEP 484) instead of function annotations!</li> <li>Always add a correct PEP 484 style type comment as the first line after the function definition!</li> <li>Use built-in collection types as generic types for annotations (PEP 585)!</li> <li>Use the | (pipe) operator for writing union types (PEP 604)!</li> <li>Avoid the use of <code>isinstance</code> at all cost!</li> <li>NEVER USE <code>isinstance</code> IN PYTHON CODE!!!</li> <li>Verification failures should always raise an error with a helpful message</li> </ul> <p>Example function with type annotations and docstring:</p> <pre><code>def tokenize_chunks(chunks, max_len=None):\n    # type: (list[str], int|None) -&gt; dict\n    \"\"\"\n    Tokenize text chunks into model-compatible formats.\n\n    :param chunks: Text chunks to tokenize.\n    :param max_len: Truncates chunks above max_len characters\n    :return: Dictionary of tokenized data including input IDs, attention masks, and type IDs.\n    \"\"\"\n</code></pre>"},{"location":"iscc-sig-spec/","title":"ISCC Signature Specification","text":"<p>This specification defines a simple JSON signature format for ISCC metadata using EdDSA signatures and JSON Canonicalization Scheme (JCS).</p>"},{"location":"iscc-sig-spec/#why-a-custom-signature-format","title":"Why a Custom Signature Format?","text":"<p>The ISCC framework requires a signature format that balances simplicity, flexibility, and standards compliance:</p> <ul> <li>Simplicity: Unlike complex standards like JSON-LD signatures or JWT, ISCC signatures are straightforward     JSON objects that developers can implement without extensive cryptographic libraries</li> <li>Flexibility: The format supports three verification modes (proof-only, self-verifying, identity-bound)     allowing use cases from simple integrity checks to full identity verification</li> <li>Minimal Dependencies: Uses only Ed25519 and JCS, avoiding heavyweight dependencies like JSON-LD processors     or JWT libraries</li> <li>Identity Agnostic: Works with any identity system (DIDs, CIDs, URLs) without requiring specific identity     infrastructure</li> <li>Backward Compatible: The simple structure ensures long-term stability and easy migration paths</li> </ul>"},{"location":"iscc-sig-spec/#overview","title":"Overview","text":"<p>ISCC Signatures add a <code>signature</code> object to any JSON document, providing cryptographic integrity and optional identity attribution. The signature is computed over the entire JSON object using JCS canonicalization.</p>"},{"location":"iscc-sig-spec/#signature-format","title":"Signature Format","text":"<pre><code>{\n  \"your\": \"data\",\n  \"signature\": {\n    \"version\": \"ISCC-SIG v1.0\",\n    \"controller\": \"&lt;optional-identity-uri&gt;\",\n    \"keyid\": \"&lt;optional-key-identifier&gt;\",\n    \"pubkey\": \"&lt;optional-multibase-public-key&gt;\",\n    \"proof\": \"&lt;multibase-signature&gt;\"\n  }\n}\n</code></pre>"},{"location":"iscc-sig-spec/#fields","title":"Fields","text":"<ul> <li>version (required): Must be <code>\"ISCC-SIG v1.0\"</code></li> <li>controller (optional): URI identifying the key controller (e.g., DID or CID)</li> <li>keyid (optional): Specific key identifier within the controller document</li> <li>pubkey (optional): Ed25519 public key in multibase format (z-base58-btc with ED01 prefix)</li> <li>proof (required): EdDSA signature in multibase format (z-base58-btc)</li> </ul>"},{"location":"iscc-sig-spec/#signature-types","title":"Signature Types","text":""},{"location":"iscc-sig-spec/#proof_only","title":"PROOF_ONLY","text":"<p>Minimal signature containing only version and proof. Requires out-of-band public key for verification.</p>"},{"location":"iscc-sig-spec/#self_verifying","title":"SELF_VERIFYING","text":"<p>Includes the public key for standalone verification without external dependencies.</p>"},{"location":"iscc-sig-spec/#identity_bound","title":"IDENTITY_BOUND","text":"<p>Includes controller URI and public key for full attribution and identity verification.</p>"},{"location":"iscc-sig-spec/#auto-default","title":"AUTO (default)","text":"<p>Includes all available fields from the signing keypair.</p>"},{"location":"iscc-sig-spec/#signing-process","title":"Signing Process","text":"<ol> <li>Ensure input JSON has no existing <code>signature</code> field</li> <li>Create a copy and add <code>signature</code> object with:<ul> <li><code>version</code>: \"ISCC-SIG v1.0\"</li> <li>Optional fields based on signature type</li> </ul> </li> <li>Canonicalize the entire object using JCS</li> <li>Sign the canonical bytes with Ed25519</li> <li>Encode signature as multibase (z-base58-btc)</li> <li>Add signature to <code>signature.proof</code> field</li> </ol>"},{"location":"iscc-sig-spec/#verification-process","title":"Verification Process","text":"<ol> <li>Extract and validate <code>signature</code> object:<ul> <li>Check <code>version</code> equals \"ISCC-SIG v1.0\"</li> <li>Extract <code>proof</code> field</li> </ul> </li> <li>Obtain public key from:<ul> <li><code>signature.pubkey</code> field (if present)</li> <li>External parameter (if provided)</li> </ul> </li> <li>Create copy without <code>signature.proof</code> field</li> <li>Canonicalize using JCS</li> <li>Verify EdDSA signature against canonical bytes</li> </ol>"},{"location":"iscc-sig-spec/#identity-verification-optional","title":"Identity Verification (Optional)","text":"<p>When an identity document is provided:</p> <ol> <li>Check if <code>signature.controller</code> exists</li> <li>Verify the public key is authorized in the identity document's <code>verificationMethod</code> array</li> <li>Match verification methods by:<ul> <li>Same controller URI AND</li> <li>Same public key value (publicKeyMultibase)</li> <li>If <code>keyid</code> is provided: also match against verification method's id</li> <li>If <code>keyid</code> is absent: the public key itself acts as the identifier</li> </ul> </li> </ol>"},{"location":"iscc-sig-spec/#implementation-requirements","title":"Implementation Requirements","text":"<ul> <li>Cryptography: Ed25519 signatures per RFC 8032</li> <li>Canonicalization: JSON Canonicalization Scheme (RFC 8785)</li> <li>Encoding: Multibase z-base58-btc for keys and signatures</li> <li>Public Keys: 34-byte format with 2-byte ED01 prefix + 32-byte key</li> <li>Signatures: 64-byte Ed25519 signatures</li> </ul>"},{"location":"iscc-sig-spec/#iscc-signature-example","title":"ISCC Signature Example","text":""},{"location":"iscc-sig-spec/#keypair-information","title":"Keypair Information","text":"<ul> <li>Public Key: <code>z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx</code></li> <li>Secret Key: <code>z3u2So9EAtuYVuxGog4F2ksFGws8YT7pBPs4xyRbv3NJgrNA</code></li> <li>Controller: <code>did:web:crypto.iscc.codes:alice</code></li> </ul>"},{"location":"iscc-sig-spec/#controlled-identity-document","title":"Controlled Identity Document","text":"<p>Must be published at http://crypto.iscc.codes/alice/did.json:</p> <pre><code>{\n  \"id\": \"did:web:crypto.iscc.codes:alice\",\n  \"verificationMethod\": [\n    {\n      \"id\": \"did:web:crypto.iscc.codes:alice#z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\",\n      \"type\": \"Multikey\",\n      \"controller\": \"did:web:crypto.iscc.codes:alice\",\n      \"publicKeyMultibase\": \"z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\"\n    }\n  ],\n  \"authentication\": [\n    \"did:web:crypto.iscc.codes:alice#z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\"\n  ],\n  \"assertionMethod\": [\n    \"did:web:crypto.iscc.codes:alice#z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\"\n  ],\n  \"capabilityDelegation\": [\n    \"did:web:crypto.iscc.codes:alice#z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\"\n  ],\n  \"capabilityInvocation\": [\n    \"did:web:crypto.iscc.codes:alice#z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\"\n  ]\n}\n</code></pre>"},{"location":"iscc-sig-spec/#document-to-be-signed","title":"Document to be Signed","text":"<pre><code>{\n  \"@context\": \"http://purl.org/iscc/context\",\n  \"@type\": \"VideoObject\",\n  \"$schema\": \"http://purl.org/iscc/schema\",\n  \"iscc\": \"ISCC:KACYPXW445FTYNJ3CYSXHAFJMA2HUWULUNRFE3BLHRSCXYH2M5AEGQY\",\n  \"name\": \"The Never Ending Story\",\n  \"description\": \"a 1984 fantasy film co-written and directed by *Wolfgang Petersen*\"\n}\n</code></pre>"},{"location":"iscc-sig-spec/#example-identity_bound-signature","title":"Example: IDENTITY_BOUND Signature","text":"<p>Includes controller URI and public key for full attribution.</p> <pre><code>{\n  \"@context\": \"http://purl.org/iscc/context\",\n  \"@type\": \"VideoObject\",\n  \"$schema\": \"http://purl.org/iscc/schema\",\n  \"iscc\": \"ISCC:KACYPXW445FTYNJ3CYSXHAFJMA2HUWULUNRFE3BLHRSCXYH2M5AEGQY\",\n  \"name\": \"The Never Ending Story\",\n  \"description\": \"a 1984 fantasy film co-written and directed by *Wolfgang Petersen*\",\n  \"signature\": {\n    \"version\": \"ISCC-SIG v1.0\",\n    \"controller\": \"did:web:crypto.iscc.codes:alice\",\n    \"pubkey\": \"z6MkpFpVngrAUTSY6PagXa1x27qZqgdmmy3ZNWSBgyFSvBSx\",\n    \"proof\": \"z3fVSTAfmNZTp1unwoXsyQa9sUx7gAxaZVavBLEPA5muup5ukxbCrirS8jcuhKzvQ3kp6UCJz2RA5wkZhYZ49o5wr\"\n  }\n}\n</code></pre>"},{"location":"tutorials/getting-started/","title":"Getting Started with ISCC-CRYPTO","text":"<p>This tutorial will guide you through the fundamental operations of cryptographic signing and verification. By the end of this tutorial, you'll be able to:</p> <ul> <li>Generate your first cryptographic keypair</li> <li>Sign a JSON document</li> <li>Verify a signed document</li> <li>Understand the signature format used by ISCC-CRYPTO</li> </ul>"},{"location":"tutorials/getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li> Python 3.10 or higher installed</li> <li> Basic familiarity with Python and command line</li> </ul>"},{"location":"tutorials/getting-started/#installation","title":"Installation","text":"<p>Install ISCC-Crypto using your preferred package manager:</p> uvpippoetry <pre><code>uv add iscc-crypto\n</code></pre> <pre><code>pip install iscc-crypto\n</code></pre> <pre><code>poetry add iscc-crypto\n</code></pre>"},{"location":"tutorials/getting-started/#setting-up-your-first-keypair","title":"Setting Up Your First Keypair","text":"<p>Let's start by generating a cryptographic keypair. A keypair consists of a public key (for verification) and a secret key (for signing).</p>"},{"location":"tutorials/getting-started/#step-1-import-the-library","title":"Step 1: Import the Library","text":"<p>Getting Started</p> <p>Create a new Python file called <code>tutorial.py</code> and follow along with each step.</p> <p>Create a new Python file called <code>tutorial.py</code> and import the necessary functions:</p> <pre><code>from iscc_crypto import key_generate\n</code></pre>"},{"location":"tutorials/getting-started/#step-2-generate-a-keypair","title":"Step 2: Generate a Keypair","text":"<p>Generate your first keypair:</p> <pre><code># Generate a new keypair\nkeypair = key_generate()\n\nprint(f\"Public key: {keypair.public_key}\")\nprint(f\"Secret key: {keypair.secret_key}\")\n</code></pre> <p>Run the script:</p> <pre><code>python tutorial.py\n</code></pre> <p>You should see output similar to:</p> <pre><code>Public key: z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK\nSecret key: z3u2SqkHt13R6Y1AQPXnG7q3aBrJnxvbTdKDG8L6Wppzs...\n</code></pre> <p>Keep Your Secret Key Safe</p> <p>The secret key is used to create signatures. Never share it or commit it to version control!</p>"},{"location":"tutorials/getting-started/#signing-your-first-json-document","title":"Signing Your First JSON Document","text":"<p>Now let's sign a JSON document using your keypair.</p>"},{"location":"tutorials/getting-started/#step-3-create-a-document-to-sign","title":"Step 3: Create a Document to Sign","text":"<p>Add the following to your <code>tutorial.py</code>:</p> <pre><code>from iscc_crypto import sign_json\n\n# Create a sample document\ndocument = {\"name\": \"Alice\", \"message\": \"Hello, ISCC-Crypto!\", \"timestamp\": \"2024-01-15T10:00:00Z\"}\n\n# Sign the document\nsigned_document = sign_json(document, keypair)\n\nprint(\"\\nSigned document:\")\nprint(signed_document)\n</code></pre> <p>Run the updated script. You'll see the document now includes a signature:</p> <pre><code>{\n  \"name\": \"Alice\",\n  \"message\": \"Hello, ISCC-Crypto!\",\n  \"timestamp\": \"2024-01-15T10:00:00Z\",\n  \"signature\": {\n    \"version\": \"ISCC-SIG v1.0\",\n    \"pubkey\": \"z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK\",\n    \"proof\": \"z2kSw1VwHDepdegj6Rw8bMD8N2o56VhkdZ2qh8MHP5cHDk...\"\n  }\n}\n</code></pre>"},{"location":"tutorials/getting-started/#verifying-a-signature","title":"Verifying a Signature","text":"<p>Let's verify that the signature is valid.</p>"},{"location":"tutorials/getting-started/#step-4-verify-the-signed-document","title":"Step 4: Verify the Signed Document","text":"<p>Add verification to your script:</p> <pre><code>from iscc_crypto import verify_json\n\n# Verify the signed document\nresult = verify_json(signed_document)\n\nprint(f\"\\nVerification result: {result.is_valid}\")\nprint(f\"Signature valid: {result.signature_valid}\")\nprint(f\"Message: {result.message}\")\n</code></pre> <p>The verification process:</p> <ol> <li>Extract the signature and public key</li> <li>Remove the signature from the document</li> <li>Verify that the signature matches the document content</li> </ol>"},{"location":"tutorials/getting-started/#understanding-the-signature-format","title":"Understanding the Signature Format","text":"<p>ISCC-Crypto uses a standardized signature format that's both human-readable and machine-verifiable.</p>"},{"location":"tutorials/getting-started/#step-5-examine-the-signature-structure","title":"Step 5: Examine the Signature Structure","text":"<p>Let's look more closely at what happens during signing:</p> <pre><code>import json\n\n# Pretty print the signed document\nprint(\"\\nDetailed signature structure:\")\nprint(json.dumps(signed_document, indent=2))\n\n# Extract just the signature component\nsignature_data = signed_document[\"signature\"]\nprint(f\"\\nPublic key length: {len(signature_data['pubkey'])}\")\nprint(f\"Signature proof length: {len(signature_data['proof'])}\")\nprint(f\"Version: {signature_data['version']}\")\n</code></pre> <p>Key points about the signature format:</p> <ul> <li>Multikey Encoding: Both keys and proofs use z-base58btc encoding for compactness</li> <li>Structured Signature: The signature object contains version info, public key, and cryptographic proof</li> <li>JSON Canonicalization: Documents are normalized before signing to ensure consistent results</li> <li>Version Control: Each signature includes a version field (\"ISCC-SIG v1.0\")</li> </ul>"},{"location":"tutorials/getting-started/#step-6-try-modifying-the-document","title":"Step 6: Try Modifying the Document","text":"<p>To understand signature verification, let's see what happens when we modify a signed document:</p> <pre><code># Create a copy and modify it\ntampered_document = signed_document.copy()\ntampered_document[\"message\"] = \"Modified message!\"\n\n# Try to verify the tampered document\ntampered_result = verify_json(tampered_document, raise_on_error=False)\n\nprint(f\"\\nTampered document verification: {tampered_result.is_valid}\")\nprint(f\"Signature valid: {tampered_result.signature_valid}\")\nprint(f\"Error message: {tampered_result.message}\")\n</code></pre> <p>You'll see that verification fails when the document is modified!</p>"},{"location":"tutorials/getting-started/#complete-example","title":"Complete Example","text":"<p>Here's the complete tutorial script:</p> <pre><code>from iscc_crypto import key_generate, sign_json, verify_json\nimport json\n\n# Generate a keypair\nkeypair = key_generate()\nprint(f\"Public key: {keypair.public_key}\")\nprint(f\"Secret key: {keypair.secret_key[:50]}...\")  # Show only part of secret key\n\n# Create and sign a document\ndocument = {\"name\": \"Alice\", \"message\": \"Hello, ISCC-Crypto!\", \"timestamp\": \"2024-01-15T10:00:00Z\"}\n\nsigned_document = sign_json(document, keypair)\nprint(\"\\nSigned document:\")\nprint(json.dumps(signed_document, indent=2))\n\n# Verify the signature\nresult = verify_json(signed_document)\nprint(f\"\\nVerification result: {result.is_valid}\")\nprint(f\"Message: {result.message}\")\n\n# Try tampering with the document\ntampered_document = signed_document.copy()\ntampered_document[\"message\"] = \"Modified message!\"\ntampered_result = verify_json(tampered_document, raise_on_error=False)\nprint(f\"\\nTampered document verification: {tampered_result.is_valid}\")\nprint(f\"Error message: {tampered_result.message}\")\n</code></pre>"},{"location":"tutorials/getting-started/#what-youve-learned","title":"What You've Learned","text":"<p>Congratulations! You've successfully:</p> <ul> <li> Generated a cryptographic keypair using Ed25519</li> <li> Signed a JSON document with your secret key</li> <li> Verified a signature using the embedded public key</li> <li> Explored how signatures protect document integrity</li> </ul>"},{"location":"tutorials/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can:</p> <ul> <li>Learn about [W3C Verifiable Credentials] for more advanced use cases</li> <li>Explore [key management strategies] for production environments</li> <li>Read about [cryptographic concepts] to understand the underlying technology</li> </ul>"},{"location":"tutorials/getting-started/#exercises","title":"Exercises","text":"<p>To reinforce your learning, try these exercises:</p> <ol> <li>Multiple Documents: Create and sign several different JSON documents with the same keypair</li> <li>Key Rotation: Generate two different keypairs and sign the same document with each</li> <li>Nested Objects: Try signing more complex JSON structures with nested objects and arrays</li> <li>Error Handling: Experiment with invalid inputs to understand error messages</li> </ol> <p>Pro Tip</p> <p>When working with real applications, store your keypairs securely using environment variables or secure key management systems. Never hardcode secret keys in your source code!</p>"}]}